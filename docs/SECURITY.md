# 安全文档：2-of-3 Shamir's Secret Sharing 方案

## 威胁模型 (Threat Model)

### 攻击者能力假设

1. **被动攻击者**
   - 能够窃取任意1个分片（如物理访问、云服务泄露）
   - 能够截获网络传输（本方案完全离线，此风险可忽略）
   - **无法从单个分片获得任何关于原始密钥的信息**（信息论安全保证）

2. **主动攻击者**
   - 能够修改存储介质（如篡改分片文件）
   - 无法同时访问2个或以上分片（物理隔离保护）

3. **长期威胁**
   - 5-10年后计算能力大幅提升（如量子计算）
   - 存储介质退化或损坏
   - 用户遗忘或丢失分片

### 安全目标

- ✅ **信息论安全**：即使攻击者拥有1个分片，也无法获得关于原始密钥的任何信息（即使在无限计算能力下）
- ✅ **可用性**：只要保留2个分片，即可100%恢复原始密钥
- ✅ **完整性**：使用Lagrange插值可检测分片是否被篡改（错误的分片无法正确恢复）

---

## 方案设计概览

### 核心原理：Shamir's Secret Sharing

本方案基于Shamir在1979年提出的秘密共享方案，使用**多项式插值**在有限域GF(256)上实现。

#### 数学基础

1. **秘密分割**：
   - 对于长度为`L`字节的秘密，为每个字节位置生成独立的`k-1`次多项式：
     ```
     f_i(x) = s_i + a₁x + a₂x² + ... + a_{k-1}x^{k-1}  (在GF(256)上)
     ```
   - 其中`s_i`是秘密的第`i`个字节，`a₁, a₂, ...`是随机生成的系数
   - 计算`n`个点：`(1, f(1)), (2, f(2)), (3, f(3))`

2. **秘密恢复**：
   - 给定任意`k`个点`(x₁, y₁), (x₂, y₂), ..., (xₖ, yₖ)`
   - 使用Lagrange插值公式计算`f(0)`，即原始秘密：
     ```
     f(0) = Σ (yᵢ × ∏ (0 - xⱼ) / (xᵢ - xⱼ))
     ```

3. **信息论安全性**：
   - 对于`k-1`个点，存在`256`个可能的`k-1`次多项式通过这`k-1`个点
   - 每个多项式对应一个不同的`f(0)`值（即不同的秘密）
   - 因此，攻击者无法从`k-1`个点获得任何关于`f(0)`的信息

### 2-of-3 配置

- **总分数**：`n = 3`
- **恢复阈值**：`k = 2`
- **安全性**：任意1个分片 = `k-1 = 1`个点，无法恢复秘密（信息论安全）
- **容错性**：可以丢失任意1个分片，仍可恢复

---

## 实现细节

### 有限域 GF(256)

使用Galois Field GF(2⁸)，以不可约多项式`x⁸ + x⁴ + x³ + x² + 1 = 0x11D`定义。

**为什么使用GF(256)？**
- 每个字节对应GF(256)中的一个元素
- 数学运算高效（使用预计算的对数表）
- 适合处理任意长度的二进制秘密

### 分片格式

每个分片编码为：
```
x:base64(share_bytes)
```
- `x`：分片的x坐标（1, 2, 或 3）
- `share_bytes`：分片的字节数据（与原始秘密等长）

**示例**：
```
1:AbCdEf123456==
2:XyZaBc789012==
3:MnBvCx345678==
```

---

## 常见错误实现（必须避免）

### ❌ 错误1：字符串简单切分

```python
# 危险！不安全的实现
def naive_split(secret):
    part1 = secret[:len(secret)//3]
    part2 = secret[len(secret)//3:2*len(secret)//3]
    part3 = secret[2*len(secret)//3:]
    return part1, part2, part3
```

**问题**：
- 每个分片包含部分原始信息
- 攻击者即使只有1个分片，也能获得部分密钥信息
- **不符合信息论安全要求**

### ❌ 错误2：XOR简单分片

```python
# 危险！不安全的实现
def xor_split(secret):
    part1 = secrets.token_bytes(len(secret))
    part2 = secrets.token_bytes(len(secret))
    part3 = bytes(a ^ b ^ c for a, b, c in zip(secret, part1, part2))
    return part1, part2, part3
```

**问题**：
- 2-of-3阈值无法实现（需要所有3个分片）
- 如果使用2-of-3，任意1个分片会泄露信息

### ❌ 错误3：使用在线服务或云API

```python
# 危险！泄露风险
import requests
shares = requests.post("https://api.example.com/split", data=secret)
```

**问题**：
- 密钥通过网络传输，可能被中间人攻击
- 第三方服务可能存储或记录密钥
- 违反"完全离线"要求

### ✅ 正确实现（本方案）

- 使用标准Shamir's Secret Sharing算法
- 在GF(256)上执行所有运算
- 使用密码学安全的随机数生成器（`secrets`模块）
- 完全本地执行，无网络依赖

---

## 安全性分析

### 信息论安全证明

**定理**：对于`k-1`个分片，攻击者无法获得关于秘密的任何信息。

**证明概要**：
1. 对于`k-1`个点`(x₁, y₁), ..., (x_{k-1}, y_{k-1})`，存在恰好`256`个`k-1`次多项式通过这些点
2. 这`256`个多项式在`x=0`处的值（即秘密）构成GF(256)的所有可能值
3. 每个可能值出现的概率相等（`1/256`）
4. 因此，攻击者无法从`k-1`个点获得关于`f(0)`的任何信息

**结论**：即使在无限计算能力下，攻击者也无法破解。

### 与计算安全性的区别

| 特性 | 信息论安全（本方案） | 计算安全（如RSA） |
|------|---------------------|------------------|
| 安全性基础 | 数学证明 | 计算复杂度假设 |
| 攻击者能力 | 无限计算能力仍安全 | 有限计算能力假设 |
| 长期安全性 | 5-10年+仍安全 | 可能被新技术破解 |

---

## 存储安全建议

### ✅ 推荐做法

1. **物理隔离存储**
   - 分片1：安全硬件钱包或加密USB（物理位置A）
   - 分片2：银行保险箱或可信第三方（物理位置B）
   - 分片3：加密备份在另一物理位置（物理位置C）

2. **加密存储（额外保护层）**
   - 每个分片文件可以用强密码加密（如AES-256）
   - 密码存储在密码管理器中
   - **注意**：这只是额外保护，不是SSS的替代

3. **多重备份**
   - 为每个分片创建多个备份（如金属板刻录、纸质打印）
   - 分散存储在不同地理位置

### ❌ 避免的做法

1. **不要存储在云端（无额外加密）**
   - ❌ Notion、Evernote、Telegram等云服务
   - ❌ 即使有密码，云服务提供商可能访问
   - ❌ 单点故障（账号被封、服务关闭）

2. **不要存储在单一位置**
   - ❌ 所有分片在同一个USB、同一台电脑
   - ❌ 所有分片在同一云账号

3. **不要通过不安全渠道传输**
   - ❌ 未加密的邮件、短信
   - ❌ 未加密的聊天软件

### 混合存储策略示例

```
分片1: 
  - 主备份：硬件钱包（在家）
  - 备用备份：银行保险箱

分片2:
  - 主备份：加密USB（办公室）
  - 备用备份：可信朋友/家人（物理信封）

分片3:
  - 主备份：加密云存储（如iCloud加密备份，需额外密码）
  - 备用备份：纸质打印（防水袋，安全位置）
```

**关键原则**：任意2个分片的存储位置不应在同一物理安全域内。

---

## 长期可维护性

### 5-10年后恢复建议

1. **保存恢复工具**
   - 本Python脚本应与分片分开存储
   - 考虑同时保存Python解释器的安装方法
   - 或使用标准工具（如`ssss`命令行工具）

2. **文档化存储位置**
   - 创建"恢复说明文档"（见`docs/RESTORE_TEMPLATE.md`）
   - 存储在密码管理器中，或告知可信第三方

3. **定期验证**
   - 每1-2年尝试使用2个分片恢复（测试恢复流程）
   - 检查分片完整性（是否损坏、是否可读取）

4. **依赖管理**
   - 本实现仅依赖Python标准库（无第三方依赖）
   - 确保Python 3.6+可用（或保存解释器版本）

### 防遗忘策略

1. **密码管理器**
   - 存储"恢复说明"和"分片存储位置"的提示
   - 主密码由可信第三方保管（如律师、家人）

2. **多重提醒**
   - 日历提醒（每年检查一次）
   - 物理提醒（如保险箱钥匙上贴标签）

3. **备份恢复文档**
   - 创建可打印的恢复说明（见`docs/RESTORE_TEMPLATE.md`）
   - 与分片分开存储，但易于找到

---

## 审计清单

在使用本方案前，请确认：

- [ ] 理解Shamir's Secret Sharing的数学原理
- [ ] 确认实现使用标准算法（非自制方案）
- [ ] 所有操作在离线环境中执行
- [ ] 3个分片存储在不同物理位置
- [ ] 创建了恢复说明文档
- [ ] 测试了恢复流程（使用2个分片成功恢复）
- [ ] 保存了恢复工具（本脚本）
- [ ] 设置了长期提醒机制

---

## 参考资料

1. **Shamir, A. (1979)**. "How to share a secret". Communications of the ACM, 22(11), 612-613.
2. **RFC 3526**: More Modular Exponential (MODP) Diffie-Hellman groups
3. **Wikipedia**: Shamir's Secret Sharing

---

**最后更新**：2024年
**版本**：1.0

