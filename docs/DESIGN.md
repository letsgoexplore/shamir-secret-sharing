# 方案设计概览

## 系统架构

### 核心组件

```
┌─────────────────────────────────────────────────────────┐
│                   输入密钥                                │
│        (hex/base64/UTF-8, 任意长度)                      │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│          Shamir's Secret Sharing 引擎                     │
│  ┌─────────────────────────────────────────────────┐   │
│  │  GF(256) 有限域运算                              │   │
│  │  - 多项式生成（每个字节独立）                     │   │
│  │  - Lagrange插值恢复                             │   │
│  └─────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              3个分片 (2-of-3方案)                         │
│  Share 1: 1:base64(...)  ←──┐                           │
│  Share 2: 2:base64(...)  ←──┼── 任意2个可恢复           │
│  Share 3: 3:base64(...)  ←──┘                           │
└─────────────────────────────────────────────────────────┘
                     │
                     ▼
┌─────────────────────────────────────────────────────────┐
│              物理隔离存储                                 │
│  位置A | 位置B | 位置C  (不同物理安全域)                 │
└─────────────────────────────────────────────────────────┘
```

---

## 算法流程

### 分割流程

```
输入: 秘密 S (L字节)
     阈值 k=2
     总分片数 n=3

For 每个字节位置 i in [0, L-1]:
  1. 生成随机系数: a₁, a₂, ..., a_{k-1} ∈ GF(256)
  2. 构造多项式: f_i(x) = S[i] + a₁x + a₂x² + ... + a_{k-1}x^{k-1}
  3. 计算分片值:
     - Share[0][i] = f_i(1)
     - Share[1][i] = f_i(2)
     - Share[2][i] = f_i(3)

输出: 3个分片，每个L字节
```

### 恢复流程

```
输入: 任意2个分片 (x₁, y₁), (x₂, y₂)

For 每个字节位置 i:
  使用Lagrange插值计算 f_i(0):
    f_i(0) = y₁ᵢ × (0-x₂)/(x₁-x₂) + y₂ᵢ × (0-x₁)/(x₂-x₁)
            (在GF(256)上)

输出: 恢复的秘密 S
```

---

## 安全保证

### 信息论安全性

| 攻击者拥有的分片数 | 可能的多项式数量 | 信息泄露 |
|-------------------|-----------------|---------|
| 0 | 256^L | 无（完全随机） |
| 1 (k-1) | 256 | 无（每个可能值等概率） |
| 2 (k) | 1 | **可唯一确定** |

**结论**：任意1个分片不泄露任何信息（信息论安全）。

### 容错性

| 丢失的分片数 | 可恢复性 | 安全性 |
|------------|---------|--------|
| 0 | ✅ 可用任意2个 | ✅ 安全 |
| 1 | ✅ 仍可用剩余2个 | ✅ 安全 |
| 2 | ❌ 无法恢复 | ✅ 安全（至少1个分片不泄露） |

---

## 实现特点

### 1. 有限域选择：GF(256)

**为什么选择GF(256)？**
- ✅ 每个字节天然对应GF(256)中的一个元素
- ✅ 运算高效（使用预计算对数表，O(1)乘除）
- ✅ 适合处理任意长度的二进制秘密
- ✅ 标准实现，易于审计

**数学性质**：
- 加法 = XOR运算
- 乘法/除法通过对数表加速
- 不可约多项式：`x⁸ + x⁴ + x³ + x² + 1`

### 2. 多项式生成策略

**每个字节独立生成多项式**：
- 优点：简单、高效、易于实现
- 安全性：每个字节位置独立，互不影响

**随机数生成**：
- 使用Python `secrets`模块（密码学安全PRNG）
- 每个系数独立随机选择

### 3. 分片格式设计

```
格式: x:base64(share_bytes)
```

**设计考虑**：
- ✅ 人类可读（base64编码）
- ✅ 包含x坐标（便于验证和恢复）
- ✅ 易于存储和传输
- ✅ 自包含（无需额外元数据）

---

## 与标准实现的对比

### 标准工具：`ssss`

| 特性 | 本实现 | ssss |
|------|--------|------|
| 算法 | Shamir SSS | Shamir SSS |
| 有限域 | GF(256) | GF(prime) 或 GF(256) |
| 输入格式 | hex/base64/UTF-8 | hex |
| 依赖 | 仅Python标准库 | 需安装工具 |
| 可审计性 | ✅ Python源码 | 需要编译 |

**本实现的优势**：
- 零依赖，长期可用
- 源码简单，易于审计
- 支持多种输入/输出格式

---

## 性能特征

### 时间复杂度

- **分割**：O(L × k)，其中L是秘密长度，k是阈值
- **恢复**：O(L × k²)，Lagrange插值的典型复杂度
- **实际性能**：32字节密钥 < 1ms（现代CPU）

### 空间复杂度

- **分片大小**：每个分片 = 原始秘密长度（L字节）
- **总存储**：3 × L字节（相比原始密钥，存储增加2倍）
- **base64编码开销**：约33%（可忽略）

---

## 威胁模型分析

### 威胁1：单个分片泄露

**攻击场景**：攻击者获得1个分片（如云存储泄露）

**防护**：
- ✅ 信息论安全保证：即使有无限计算能力也无法破解
- ✅ 数学证明：存在256个等概率的可能秘密

**结论**：**安全**

### 威胁2：存储介质损坏

**攻击场景**：1个分片存储介质损坏（如USB损坏）

**防护**：
- ✅ 2-of-3容错：丢失1个分片仍可恢复
- ✅ 建议：为每个分片创建多个备份

**结论**：**可恢复**

### 威胁3：同时泄露2个分片

**攻击场景**：攻击者同时获得2个分片（如物理访问2个存储位置）

**防护**：
- ⚠️ 如果攻击者获得2个分片，可以恢复密钥
- ✅ **缓解措施**：物理隔离，确保2个分片不在同一安全域

**结论**：**需要物理隔离措施**

### 威胁4：长期计算能力提升

**攻击场景**：5-10年后，量子计算等技术大幅提升

**防护**：
- ✅ 信息论安全不依赖于计算复杂度
- ✅ 即使有无限计算能力也无法破解（单个分片）

**结论**：**长期安全**

---

## 部署建议

### 最小化部署

1. **必备文件**：
   - `src/sss_tool.py`（核心工具）
   - `docs/RESTORE_TEMPLATE.md`（恢复说明）

2. **可选文件**：
   - `docs/SECURITY.md`（安全文档）
   - `README.md`（使用说明）

### 推荐部署

1. **本地使用**：
   ```bash
   # 1. 下载工具
   git clone <repo> 或直接下载整个项目
   
   # 2. 生成分片
   python3 src/sss_tool.py split <secret>
   
   # 3. 保存分片和恢复说明到不同位置
   ```

2. **离线环境**：
   - 所有操作在离线电脑上执行
   - 通过加密USB传输分片到其他存储位置

---

## 长期维护计划

### 5年维护检查清单

- [ ] 验证Python 3.6+仍可用
- [ ] 测试恢复流程（使用2个分片）
- [ ] 检查分片存储完整性
- [ ] 更新恢复说明（如存储位置变更）

### 10年维护检查清单

- [ ] 评估是否需要迁移到新工具
- [ ] 验证数学实现的长期正确性
- [ ] 检查是否有更好的长期存储介质（如金属板）

---

## 扩展可能性

### 未来增强（可选）

1. **3-of-5方案**：
   - 修改 `n=5, k=3` 参数
   - 更高的容错性（可丢失2个分片）

2. **分片加密**：
   - 每个分片用AES-256加密
   - 密码存储在密码管理器

3. **验证码**：
   - 为每个分片添加校验和
   - 检测分片是否被篡改

4. **图形界面**：
   - 简单的GUI工具
   - 降低使用门槛

**注意**：当前实现已满足所有安全要求，扩展功能为可选。

---

## 结论

本方案提供：

✅ **信息论安全**：单个分片不泄露任何信息  
✅ **高可用性**：2-of-3容错，丢失1个仍可恢复  
✅ **长期可用**：零依赖，易于维护  
✅ **易于使用**：命令行工具，支持多种格式  
✅ **完整文档**：安全分析、使用指南、恢复模板  

**适合场景**：
- 高价值密钥长期存储
- 需要物理隔离的场景
- 对安全性要求极高的场景

---

**版本**：1.0  
**最后更新**：2024年

